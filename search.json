[{"path":"https://rdinnager.github.io/tidysdm/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2022 tidysdm authors Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://rdinnager.github.io/tidysdm/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Russell Dinnage. Author, maintainer.","code":""},{"path":"https://rdinnager.github.io/tidysdm/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Dinnage R (2023). tidysdm: Sprecies Distribution Modelling Tidymodels. R package version 0.0.0.9000, https://rdinnager.github.io/tidysdm/.","code":"@Manual{,   title = {tidysdm: Sprecies Distribution Modelling with Tidymodels},   author = {Russell Dinnage},   year = {2023},   note = {R package version 0.0.0.9000},   url = {https://rdinnager.github.io/tidysdm/}, }"},{"path":"https://rdinnager.github.io/tidysdm/index.html","id":"tidysdm","dir":"","previous_headings":"","what":"Sprecies Distribution Modelling with Tidymodels","title":"Sprecies Distribution Modelling with Tidymodels","text":"tidysdm package make easy fit Species Distribution Models tidymodels framework.","code":""},{"path":"https://rdinnager.github.io/tidysdm/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Sprecies Distribution Modelling with Tidymodels","text":"can install development version tidysdm GitHub :","code":"# install.packages(\"devtools\") devtools::install_github(\"rdinnager/tidysdm\")"},{"path":"https://rdinnager.github.io/tidysdm/index.html","id":"example","dir":"","previous_headings":"","what":"Example","title":"Sprecies Distribution Modelling with Tidymodels","text":"use data ENMTools package demonstrate tidysdm works. start generating {tidymodels} compatable sf object species want model.  Now can use spatialsample package create spatial cross validation folds! first create regular cross validation fold object comparison. Note can take awhile spatial distance calculated points! working faster method pseudo-absence data.    Let’s create recipe apply common data processing steps prepare SDM fitting. start step_add_env_vars(), tidymodels function. rest standard steps recipes package. step_impute_median() imputes missing values (since random forest model handle missing values). step_YeoJohnson() Yeo-Johnson transformation predictors, makes symmetric ‘Gaussian-like’. also saves parameters used transformation automatically applied test data used prediction later. Finally step_normalize() transforms predictors mean zero standard deviation 1, scale. also saves means sds applied test data. see result step run prep() bake(new_data = NULL). Now can setup random forest model parsnip combine recipe using workflow workflows package.. Now fit model! start regular cross validation folds, use fit_resamples() generate metrics based fits validation sets folds. collect_metrics() calculate means across folds us. Okay, ROC AUC value pretty good around 0.82. Now spatial cross validation folds. Using spatially independent cross validation folds shown us model much poorly ask generalise spatial areas training set. Now ROC AUC ~ 0.58 – considerably worse. Looking individual folds, substantial variation quality models. first fold model looks done reasonable job. one ?  Let’s look importance values determined random forest variables.  ordering reasonably consistent different folds. Now, spatial folds:  seems quite bit variation variables important different spatial folds. interesting. can try improve performance model spatially independent data using spatial cross validation folds tune hyperparameters model. can use tune package . Using tune_bayes() can use Bayesian optimization find optimal set. hyperparameters tune. random forest three, mtry, trees, min_n. Let’s try tuning three. First make new model object designate parameters tuning, wrap new workflow. Tuning now simple calling tune_bayes(). First set initial set tuning models using tuning grid (regularly spaced values hyper-parameters). way, take awhile. want computer recommend setting parallel backend tuning (see https://tune.tidymodels.org/articles/extras/optimizations.html). Now serves initial values tune_bayes(). haven’t much improved ability model predict spatially separated testing data sets! surprising since random forest generally doesn’t need much tuning. ultimately, problem poor hyper-parameters overfitting spatial patterns found data. prevented except finding way help model ‘account’ spatial autocorrelation data. approaches , might help, can go far. problem space impossible make go away completely, least using statistical methods. Note best solutions low mtry. means random forest using 1 3 variables time make predictions. implies variable contain mostly amount information don’t interact much, suggesting climate predictors little species distribution, mainly used spatial information. best bet , cases find better predictors definitely related species’ known ecology! Lastly, tidysdm makes easy generate visualizable predictions original landscape using create_prediction_grid() function, creates grid x y values, optionally polygon attached help plotting. Feeding augment function automatically make predictions based model bind prediction back prediction grid data, ready plotting. make hexagons look much cooler squares (just use square = FALSE). Now make predictions first final fit random forest model full data set, using best hyper-parameters spatial cross validation.","code":"library(tidysdm) #> Loading required package: parsnip #> Loading required package: recipes #> Loading required package: dplyr #>  #> Attaching package: 'dplyr' #> The following objects are masked from 'package:stats': #>  #>     filter, lag #> The following objects are masked from 'package:base': #>  #>     intersect, setdiff, setequal, union #>  #> Attaching package: 'recipes' #> The following object is masked from 'package:stats': #>  #>     step set.seed(112233) library(ENMTools) #> Loading required package: raster #> Loading required package: sp #>  #> Attaching package: 'raster' #> The following object is masked from 'package:dplyr': #>  #>     select #> Loading required package: dismo library(tidyverse) #> ── Attaching packages #> ─────────────────────────────────────── #> tidyverse 1.3.2 ── #> ✔ ggplot2 3.3.6     ✔ purrr   0.3.5 #> ✔ tibble  3.1.8     ✔ stringr 1.4.1 #> ✔ tidyr   1.2.1     ✔ forcats 0.5.2 #> ✔ readr   2.1.3      #> ── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ── #> ✖ tidyr::extract() masks raster::extract() #> ✖ dplyr::filter()  masks stats::filter() #> ✖ stringr::fixed() masks recipes::fixed() #> ✖ dplyr::lag()     masks stats::lag() #> ✖ raster::select() masks dplyr::select() library(tidymodels) #> ── Attaching packages ────────────────────────────────────── tidymodels 1.0.0 ── #> ✔ broom        1.0.1     ✔ tune         1.0.1 #> ✔ dials        1.0.0     ✔ workflows    1.1.0 #> ✔ infer        1.0.3     ✔ workflowsets 1.0.0 #> ✔ modeldata    1.0.1     ✔ yardstick    1.1.0 #> ✔ rsample      1.1.0      #> ── Conflicts ───────────────────────────────────────── tidymodels_conflicts() ── #> ✖ scales::discard()  masks purrr::discard() #> ✖ tidyr::extract()   masks raster::extract() #> ✖ dplyr::filter()    masks stats::filter() #> ✖ stringr::fixed()   masks recipes::fixed() #> ✖ dplyr::lag()       masks stats::lag() #> ✖ raster::select()   masks dplyr::select() #> ✖ yardstick::spec()  masks readr::spec() #> ✖ recipes::step()    masks stats::step() #> ✖ dials::threshold() masks dismo::threshold() #> ✖ raster::update()   masks recipes::update(), stats::update() #> • Use tidymodels_prefer() to resolve common conflicts. library(spatialsample) data(\"iberolacerta.clade\") data(\"euro.worldclim\") monticola <- iberolacerta.clade$species$monticola dat <- sdm_data(monticola$presence.points,                 bg = monticola$range,                 n = 5000,                 coords = c(\"Longitude\",                            \"Latitude\"),                 crs = 4326)  dat #> Simple feature collection with 5260 features and 2 fields #> Geometry type: POINT #> Dimension:     XY #> Bounding box:  xmin: -9.31549 ymin: 39.83402 xmax: 0.6627441 ymax: 43.8299 #> Geodetic CRS:  WGS 84 #> First 10 features: #>    present pnt_origin                       pnts #> 1  present       data POINT (-5.171215 43.06957) #> 2  present       data POINT (-6.036635 43.02531) #> 3  present       data POINT (-7.679727 40.38852) #> 4  present       data POINT (-7.790437 40.30959) #> 5  present       data  POINT (-7.47334 43.78935) #> 6  present       data  POINT (-6.575039 42.9107) #> 7  present       data POINT (-5.132756 43.49572) #> 8  present       data POINT (-7.787378 40.39362) #> 9  present       data  POINT (-4.941888 43.3531) #> 10 present       data  POINT (-7.621731 40.3417)  plot(dat %>%         dplyr::select(present) %>%         arrange(present),       pch = 19) ## regular CV cv_folds <- vfold_cv(dat, 9)  ## spatial CV cv_folds_spat <- spatial_block_cv(dat, method = \"snake\",                              n = c(6, 4),                              v = 9,                              buffer = 50000) cv_folds_spat #> #  9-fold spatial block cross-validation  #> # A tibble: 9 × 2 #>   splits              id    #>   <list>              <chr> #> 1 <split [3098/902]>  Fold1 #> 2 <split [4056/427]>  Fold2 #> 3 <split [3923/761]>  Fold3 #> 4 <split [4175/517]>  Fold4 #> 5 <split [4408/375]>  Fold5 #> 6 <split [4501/71]>   Fold6 #> 7 <split [4293/210]>  Fold7 #> 8 <split [3346/789]>  Fold8 #> 9 <split [3246/1207]> Fold9  ## look at the spatial folds autoplot(cv_folds_spat) autoplot(cv_folds_spat$splits[[1]]) autoplot(cv_folds_spat$splits[[8]]) sdm_recipe <- recipe(dat) %>%   step_add_env_vars(env = euro.worldclim) %>%   step_impute_median(all_predictors()) %>%   step_YeoJohnson(all_predictors()) %>%   step_normalize(all_predictors())  test <- prep(sdm_recipe) %>%   bake(NULL)  test #> # A tibble: 5,260 × 22 #>    present                 pnts pnt_origin   bio1    bio2   bio3     bio4 #>    <fct>            <POINT [°]> <fct>       <dbl>   <dbl>  <dbl>    <dbl> #>  1 present (-5.171215 43.06957) data       -1.47   0.167   0.777 -0.332   #>  2 present (-6.036635 43.02531) data       -1.53   0.167   0.777 -0.336   #>  3 present (-7.679727 40.38852) data        1.07  -0.332  -0.193 -0.0434  #>  4 present (-7.790437 40.30959) data        0.645 -0.763  -1.16  -0.0264  #>  5 present  (-7.47334 43.78935) data        1.23  -1.44    1.76  -1.61    #>  6 present  (-6.575039 42.9107) data       -1.28   0.0786  0.777 -0.248   #>  7 present (-5.132756 43.49572) data        0.854 -1.35    1.27  -1.33    #>  8 present (-7.787378 40.39362) data        1.07  -0.332  -0.193 -0.0434  #>  9 present  (-4.941888 43.3531) data        0.593 -1.35    0.777 -1.27    #> 10 present  (-7.621731 40.3417) data       -0.644 -1.44   -2.58   0.00321 #> # … with 5,250 more rows, and 15 more variables: bio5 <dbl>, bio6 <dbl>, #> #   bio7 <dbl>, bio8 <dbl>, bio9 <dbl>, bio10 <dbl>, bio11 <dbl>, bio12 <dbl>, #> #   bio13 <dbl>, bio14 <dbl>, bio15 <dbl>, bio16 <dbl>, bio17 <dbl>, #> #   bio18 <dbl>, bio19 <dbl> mod <- rand_forest() %>%   set_engine(\"ranger\", importance = \"impurity\") %>%   set_mode(\"classification\")  wf <- workflow() %>%   add_recipe(sdm_recipe) %>%   add_model(mod,             formula = present ~ .)  wf #> ══ Workflow ════════════════════════════════════════════════════════════════════ #> Preprocessor: Recipe #> Model: rand_forest() #>  #> ── Preprocessor ──────────────────────────────────────────────────────────────── #> 4 Recipe Steps #>  #> • step_add_env_vars() #> • step_impute_median() #> • step_YeoJohnson() #> • step_normalize() #>  #> ── Model ─────────────────────────────────────────────────────────────────────── #> Random Forest Model Specification (classification) #>  #> Engine-Specific Arguments: #>   importance = impurity #>  #> Computational engine: ranger fit_1 <- wf %>%   fit_resamples(cv_folds,                  control = control_resamples(extract = extract_fit_engine))  fit_1 %>%   collect_metrics() #> # A tibble: 2 × 6 #>   .metric  .estimator  mean     n std_err .config              #>   <chr>    <chr>      <dbl> <int>   <dbl> <chr>                #> 1 accuracy binary     0.948     9 0.00311 Preprocessor1_Model1 #> 2 roc_auc  binary     0.824     9 0.0121  Preprocessor1_Model1 fit_2 <- wf %>%   fit_resamples(cv_folds_spat,                 control = control_resamples(extract = extract_fit_engine)) #> ! Fold6: internal: No control observations were detected in `truth` with control level 'pre... #> ! Fold7: internal: No control observations were detected in `truth` with control level 'pre...  fit_2 %>%   collect_metrics() #> # A tibble: 2 × 6 #>   .metric  .estimator  mean     n std_err .config              #>   <chr>    <chr>      <dbl> <int>   <dbl> <chr>                #> 1 accuracy binary     0.968     9  0.0127 Preprocessor1_Model1 #> 2 roc_auc  binary     0.577     7  0.0541 Preprocessor1_Model1 fit_2$.metrics #> [[1]] #> # A tibble: 2 × 4 #>   .metric  .estimator .estimate .config              #>   <chr>    <chr>          <dbl> <chr>                #> 1 accuracy binary         0.955 Preprocessor1_Model1 #> 2 roc_auc  binary         0.775 Preprocessor1_Model1 #>  #> [[2]] #> # A tibble: 2 × 4 #>   .metric  .estimator .estimate .config              #>   <chr>    <chr>          <dbl> <chr>                #> 1 accuracy binary         0.991 Preprocessor1_Model1 #> 2 roc_auc  binary         0.743 Preprocessor1_Model1 #>  #> [[3]] #> # A tibble: 2 × 4 #>   .metric  .estimator .estimate .config              #>   <chr>    <chr>          <dbl> <chr>                #> 1 accuracy binary         0.989 Preprocessor1_Model1 #> 2 roc_auc  binary         0.503 Preprocessor1_Model1 #>  #> [[4]] #> # A tibble: 2 × 4 #>   .metric  .estimator .estimate .config              #>   <chr>    <chr>          <dbl> <chr>                #> 1 accuracy binary         0.983 Preprocessor1_Model1 #> 2 roc_auc  binary         0.454 Preprocessor1_Model1 #>  #> [[5]] #> # A tibble: 2 × 4 #>   .metric  .estimator .estimate .config              #>   <chr>    <chr>          <dbl> <chr>                #> 1 accuracy binary         0.984 Preprocessor1_Model1 #> 2 roc_auc  binary         0.476 Preprocessor1_Model1 #>  #> [[6]] #> # A tibble: 2 × 4 #>   .metric  .estimator .estimate .config              #>   <chr>    <chr>          <dbl> <chr>                #> 1 accuracy binary             1 Preprocessor1_Model1 #> 2 roc_auc  binary            NA Preprocessor1_Model1 #>  #> [[7]] #> # A tibble: 2 × 4 #>   .metric  .estimator .estimate .config              #>   <chr>    <chr>          <dbl> <chr>                #> 1 accuracy binary             1 Preprocessor1_Model1 #> 2 roc_auc  binary            NA Preprocessor1_Model1 #>  #> [[8]] #> # A tibble: 2 × 4 #>   .metric  .estimator .estimate .config              #>   <chr>    <chr>          <dbl> <chr>                #> 1 accuracy binary         0.919 Preprocessor1_Model1 #> 2 roc_auc  binary         0.437 Preprocessor1_Model1 #>  #> [[9]] #> # A tibble: 2 × 4 #>   .metric  .estimator .estimate .config              #>   <chr>    <chr>          <dbl> <chr>                #> 1 accuracy binary         0.894 Preprocessor1_Model1 #> 2 roc_auc  binary         0.653 Preprocessor1_Model1 autoplot(cv_folds_spat$splits[[1]]) library(vip) #>  #> Attaching package: 'vip' #> The following object is masked from 'package:utils': #>  #>     vi library(patchwork) #>  #> Attaching package: 'patchwork' #> The following object is masked from 'package:raster': #>  #>     area  fit_1 %>%   unnest(.extracts) %>%   pull(.extracts) %>%   map(vip) %>%   wrap_plots(ncol = 3, nrow = 3) fit_2 %>%   unnest(.extracts) %>%   pull(.extracts) %>%   map(vip) %>%   wrap_plots(ncol = 3, nrow = 3) mod_tune <- rand_forest(mtry = tune(),                         trees = tune(),                         min_n = tune()) %>%   set_engine(\"ranger\", importance = \"impurity\") %>%   set_mode(\"classification\")  wf_tune <- workflow() %>%   add_recipe(sdm_recipe) %>%   add_model(mod_tune,             formula = present ~ .)  wf_tune #> ══ Workflow ════════════════════════════════════════════════════════════════════ #> Preprocessor: Recipe #> Model: rand_forest() #>  #> ── Preprocessor ──────────────────────────────────────────────────────────────── #> 4 Recipe Steps #>  #> • step_add_env_vars() #> • step_impute_median() #> • step_YeoJohnson() #> • step_normalize() #>  #> ── Model ─────────────────────────────────────────────────────────────────────── #> Random Forest Model Specification (classification) #>  #> Main Arguments: #>   mtry = tune() #>   trees = tune() #>   min_n = tune() #>  #> Engine-Specific Arguments: #>   importance = impurity #>  #> Computational engine: ranger tune_init <- wf_tune %>%   tune_grid(cv_folds_spat,             grid = 27,             control = control_grid(verbose = interactive())) final_params <- extract_parameter_set_dials(mod_tune) %>%   finalize(dat)  tuned <- wf_tune %>%   tune_bayes(cv_folds_spat,              initial = tune_init,              iter = 50,              param_info = final_params,              control = control_bayes(verbose = interactive(),                                      no_improve = 50L)) tuned %>%   show_best() pred_grid <- create_prediction_grid(bg = monticola$range, n = 2500, square = FALSE, include_polygons = TRUE) plot(pred_grid$polygon) final_fit <- wf_tune %>%   finalize_workflow(select_best(tuned)) %>%   fit(dat) final_fit ## Does not work yet pred_grid_preds <- final_fit %>%   augment(pred_grid)"},{"path":"https://rdinnager.github.io/tidysdm/reference/add_env_vars.html","id":null,"dir":"Reference","previous_headings":"","what":"Add environmental variables — add_env_vars","title":"Add environmental variables — add_env_vars","text":"Add environmental variables","code":""},{"path":"https://rdinnager.github.io/tidysdm/reference/add_env_vars.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add environmental variables — add_env_vars","text":"","code":"add_env_vars(x, env)"},{"path":"https://rdinnager.github.io/tidysdm/reference/add_env_vars.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add environmental variables — add_env_vars","text":"env","code":""},{"path":"https://rdinnager.github.io/tidysdm/reference/create_background.html","id":null,"dir":"Reference","previous_headings":"","what":"Make background from points — create_background","title":"Make background from points — create_background","text":"Make background points","code":""},{"path":"https://rdinnager.github.io/tidysdm/reference/create_background.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Make background from points — create_background","text":"","code":"create_background(   x,   method = c(\"convex_hull\", \"point_buffer\", \"ecoregion\", \"concave_hull\", \"grid_fill\",     \"user_fill\"),   buffer = 0,   max_bg = NULL,   grid_options = NULL,   concave_options = NULL )"},{"path":"https://rdinnager.github.io/tidysdm/reference/create_background.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Make background from points — create_background","text":"concave_options","code":""},{"path":"https://rdinnager.github.io/tidysdm/reference/create_prediction_grid.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate a grid of values for making predictions — create_prediction_grid","title":"Generate a grid of values for making predictions — create_prediction_grid","text":"Generate grid values making predictions","code":""},{"path":"https://rdinnager.github.io/tidysdm/reference/create_prediction_grid.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate a grid of values for making predictions — create_prediction_grid","text":"","code":"create_prediction_grid(bg, n = 10000, square = TRUE, include_polygons = FALSE)"},{"path":"https://rdinnager.github.io/tidysdm/reference/create_prediction_grid.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate a grid of values for making predictions — create_prediction_grid","text":"include_polygons","code":""},{"path":"https://rdinnager.github.io/tidysdm/reference/get_spatial_neighbours.html","id":null,"dir":"Reference","previous_headings":"","what":"Get Spatial Neighbours — get_spatial_neighbours","title":"Get Spatial Neighbours — get_spatial_neighbours","text":"Get Spatial Neighbours","code":""},{"path":"https://rdinnager.github.io/tidysdm/reference/get_spatial_neighbours.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get Spatial Neighbours — get_spatial_neighbours","text":"","code":"get_spatial_neighbours(   x,   k = 8,   maxdist = 1e+05,   progress = TRUE,   parallel = 1 )"},{"path":"https://rdinnager.github.io/tidysdm/reference/get_spatial_neighbours.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get Spatial Neighbours — get_spatial_neighbours","text":"x sf object k number nearest neighbours retrieve maxdist maximum distance get nearest neighbours progress Print progess bar? parallel many parallel cores use.","code":""},{"path":"https://rdinnager.github.io/tidysdm/reference/get_spatial_neighbours.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get Spatial Neighbours — get_spatial_neighbours","text":"list neighbour indices","code":""},{"path":"https://rdinnager.github.io/tidysdm/reference/po_spatial_buffer_vfold_cv.html","id":null,"dir":"Reference","previous_headings":"","what":"Spatial Cross Validation Designed for Presence-Only Data — po_spatial_buffer_vfold_cv","title":"Spatial Cross Validation Designed for Presence-Only Data — po_spatial_buffer_vfold_cv","text":"Spatial Cross Validation Designed Presence-Data","code":""},{"path":"https://rdinnager.github.io/tidysdm/reference/po_spatial_buffer_vfold_cv.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Spatial Cross Validation Designed for Presence-Only Data — po_spatial_buffer_vfold_cv","text":"","code":"po_spatial_buffer_vfold_cv(   data,   radius = NULL,   buffer = 0.1,   v = 10,   repeats = 1,   presence = NULL,   pool = 0.1,   ... )"},{"path":"https://rdinnager.github.io/tidysdm/reference/po_spatial_buffer_vfold_cv.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Spatial Cross Validation Designed for Presence-Only Data — po_spatial_buffer_vfold_cv","text":"...","code":""},{"path":"https://rdinnager.github.io/tidysdm/reference/sdm_data.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert presence points and a background area\ninto an sdm_data object suitable for a\ntidysdm workflow. — sdm_data","title":"Convert presence points and a background area\ninto an sdm_data object suitable for a\ntidysdm workflow. — sdm_data","text":"Convert presence points background area sdm_data object suitable tidysdm workflow.","code":""},{"path":"https://rdinnager.github.io/tidysdm/reference/sdm_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert presence points and a background area\ninto an sdm_data object suitable for a\ntidysdm workflow. — sdm_data","text":"","code":"sdm_data(pres, bg, n = 500, abs = NULL, sample_options = list(), ...)"},{"path":"https://rdinnager.github.io/tidysdm/reference/sdm_data.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert presence points and a background area\ninto an sdm_data object suitable for a\ntidysdm workflow. — sdm_data","text":"pres Points representing species occurrences. sf object crs information bg background area sf polygon raster mask (stars raster format) n Integer specifying number background pseudo-absence points sample background specified bg. abs Optionally sf object true absence data form points. ...","code":""},{"path":"https://rdinnager.github.io/tidysdm/reference/sdm_data.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert presence points and a background area\ninto an sdm_data object suitable for a\ntidysdm workflow. — sdm_data","text":"sdm_data object inheriting tibble","code":""},{"path":"https://rdinnager.github.io/tidysdm/reference/step_sample_pseudo_absences.html","id":null,"dir":"Reference","previous_headings":"","what":"Title — step_sample_pseudo_absences","title":"Title — step_sample_pseudo_absences","text":"Title","code":""},{"path":"https://rdinnager.github.io/tidysdm/reference/step_sample_pseudo_absences.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Title — step_sample_pseudo_absences","text":"","code":"step_sample_pseudo_absences(   recipe,   bg_geometry = NULL,   role = NA,   trained = FALSE,   size,   options = list(type = \"random\", exact = FALSE),   skip = FALSE,   id = rand_id(\"sample_pseudo_absences\") )"},{"path":"https://rdinnager.github.io/tidysdm/reference/step_sample_pseudo_absences.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Title — step_sample_pseudo_absences","text":"id","code":""},{"path":"https://rdinnager.github.io/tidysdm/reference/tidyeval.html","id":null,"dir":"Reference","previous_headings":"","what":"Tidy eval helpers — tidyeval","title":"Tidy eval helpers — tidyeval","text":"page lists tidy eval tools reexported package rlang. learn using tidy eval scripts packages high level, see dplyr programming vignette ggplot2 packages vignette. Metaprogramming section Advanced R may also useful deeper dive. tidy eval operators {{, !!, !!! syntactic constructs specially interpreted tidy eval functions. mostly need {{, !! !!! advanced operators use simple cases. curly-curly operator {{ allows tunnel data-variables passed function arguments inside tidy eval functions. {{ designed individual arguments. pass multiple arguments contained dots, use ... normal way.   enquo() enquos() delay execution one several function arguments. former returns single expression, latter returns list expressions. defused, expressions longer evaluate . must injected back evaluation context !! (single expression) !!! (list expressions).   simple case, code equivalent usage {{ ... . Defusing enquo() enquos() needed complex cases, instance need inspect modify expressions way. .data pronoun object represents current slice data. variable name string, use .data pronoun subset variable [[.   Another tidy eval operator :=. makes possible use glue curly-curly syntax LHS =. technical reasons, R language support complex expressions left =, use := workaround.   Many tidy eval functions like dplyr::mutate() dplyr::summarise() give automatic name unnamed inputs. need create sort automatic names , use as_label(). instance, glue-tunnelling syntax can reproduced manually :   Expressions defused enquo() (tunnelled {{) need simple column names, can arbitrarily complex. as_label() handles cases gracefully. code assumes simple column name, use as_name() instead. safer throws error input name expected.","code":"my_function <- function(data, var, ...) {   data %>%     group_by(...) %>%     summarise(mean = mean({{ var }})) } my_function <- function(data, var, ...) {   # Defuse   var <- enquo(var)   dots <- enquos(...)    # Inject   data %>%     group_by(!!!dots) %>%     summarise(mean = mean(!!var)) } my_var <- \"disp\" mtcars %>% summarise(mean = mean(.data[[my_var]])) my_function <- function(data, var, suffix = \"foo\") {   # Use `{{` to tunnel function arguments and the usual glue   # operator `{` to interpolate plain strings.   data %>%     summarise(\"{{ var }}_mean_{suffix}\" := mean({{ var }})) } my_function <- function(data, var, suffix = \"foo\") {   var <- enquo(var)   prefix <- as_label(var)   data %>%     summarise(\"{prefix}_mean_{suffix}\" := mean(!!var)) }"}]
